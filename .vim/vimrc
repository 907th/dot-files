set nocompatible

" vim-plug {{{

call plug#begin('~/.vim/plugged')

Plug 'jeffkreeftmeijer/vim-dim'
Plug 'itchyny/lightline.vim'
Plug 'jeetsukumaran/vim-buffergator'
Plug 'schickling/vim-bufonly'
Plug 'szw/vim-maximizer'
Plug 'majutsushi/tagbar'
Plug 'junegunn/fzf', { 'do': { -> fzf#install()  }  }
Plug 'jiangmiao/auto-pairs'
Plug 'mileszs/ack.vim'
Plug 'bronson/vim-trailing-whitespace'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'Lokaltog/vim-easymotion'
Plug 'junegunn/vim-easy-align'
Plug 'dockyard/vim-easydir'
Plug 'MarcWeber/vim-addon-mw-utils' " dependency of vim-snipmate
Plug 'tomtom/tlib_vim' " dependency of vim-snipmate
Plug 'garbas/vim-snipmate'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-rails'
Plug 'tommcdo/vim-fubitive'
Plug 'vim-ruby/vim-ruby'
Plug 'noprompt/vim-yardoc'
Plug 'honza/dockerfile.vim'
Plug 'pangloss/vim-javascript'
Plug 'posva/vim-vue'
Plug 'cakebaker/scss-syntax.vim'

call plug#end()

" }}}

" Main settings {{{

syntax on
colorscheme dim

" Enable RGB colors
set termguicolors
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

filetype on
filetype plugin on
filetype indent on

set autoindent
set autoread
set number
set relativenumber
set wrap
set hidden
set fileencoding=utf-8
set mouse=a
set mousehide
set backspace=2
set laststatus=2
set scrolloff=2
set sidescrolloff=4
set incsearch
set hlsearch
set ignorecase
set smartcase
set foldenable
set foldmethod=indent
set foldlevelstart=99
set showcmd
set wildmenu
set wildmode=list:longest
set completeopt=menuone,preview
set nobackup
set nowritebackup
set noswapfile
set listchars=tab:\ \ ,trail:.
set list
set colorcolumn=80
set splitright
set splitbelow
set cursorline
set noshowmode
set diffopt=filler,vertical
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=0

autocmd FileType * setlocal
\ formatoptions-=c
\ formatoptions-=r
\ formatoptions-=o

" }}}

" Plugins config {{{

let g:buffergator_sort_regime = 'mru'
let g:buffergator_show_full_directory_path = 0
let g:buffergator_autoexpand_on_split = 0
let g:buffergator_viewport_split_policy  = 'B'
let g:buffergator_split_size = 12
let g:buffergator_suppress_keymaps = 1

let g:tagbar_compact = 1
let g:tagbar_autofocus = 1
let g:tagbar_autoshowtag = 1
let g:tagbar_width = 35
let g:tagbar_left = 1
let g:tagbar_sort = 0

let g:EasyMotion_leader_key = '<Leader>'

let g:ackprg = 'ag --vimgrep'
cnoreabbrev Ag Ack!

let g:typescript_compiler_binary = './npm_exec tsc'

let g:maximizer_set_default_mapping = 0
let g:maximizer_restore_on_winleave = 1

let g:AutoPairsShortcutToggle = ''
let g:AutoPairsShortcutJump = ''
let g:AutoPairsShortcutFastWrap = "<M-'>"
let g:AutoPairsShortcutBackInsert = '<M-[>'
let g:AutoPairsCenterLine = 0

let g:javascript_plugin_jsdoc = 1

let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_auto_colors = 1
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  ctermbg=233
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=234

let g:snipMate = { 'snippet_version' : 1 }

" }}}

" Key mappings {{{
" Hint: Use `sed -n l` to debug which sequence terminal sends on key press

nmap <Down> gj
nmap <Up> gk
vmap <Down> gj
vmap <Up> gk

noremap <expr> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <Home> <C-o><Home>

nnoremap <CR> o<Esc>
nnoremap <Backspace> O<Esc>

nnoremap <Del> a<Space><Esc>
nnoremap <Space> i<Space><Esc>

" <M-Up/Down>
imap [1;3A <C-o>O
imap [1;3B <C-o>o

" <S-Up/Down>
nmap [1;2A] 15<C-y>
nmap [1;2B] 15<C-e>
imap [1;2A] <C-o>15<C-y>
imap [1;2B] <C-o>15<C-e>

" <S-M-Up/Down>
nmap [1;10A <C-y>
nmap [1;10B <C-e>
imap [1;10A <C-o><C-y>
imap [1;10B <C-o><C-e>

" <S-Left/Right>
nmap [1;2D <<
nmap [1;2C >>
imap [1;2D <C-o><<
imap [1;2C <C-o>>>

" Move cursor after inserting new line a little
" to disable default blank line deletion behaviour.
nnoremap <C-j> i<CR><Left><Right><Esc>k$
nnoremap o o<Left><Right>
nnoremap O O<Left><Right>
nnoremap S S<Left><Right>

" <F1/2/3/5/9/10>
nmap <silent> OP :help <C-r><C-w><CR>
nmap <silent> OQ :tabnew<CR>
nmap <silent> OR :tabclose<CR>
nmap <silent> [15~ :checktime<CR>
nmap <silent> [20~ :tabnew<CR>:tabonly<CR>:BufOnly<CR>
nmap <silent> [21~ :qa<CR>

" <M-1/2/3/4>
nmap <silent> 1 :BuffergatorToggle<CR>
nmap <silent> 2 :TagbarToggle<CR>
nmap <silent> 3 :copen<CR>
nmap <silent> 4 :lopen<CR>

nmap <Leader>ss :s/
nmap <Leader>sa :%s/
nmap <Leader>sw :%s/<C-R><C-W>/

nmap <Leader>' :s/'/"/g<CR>
nmap <Leader>" :s/"/'/g<CR>

nmap <silent> <Leader>yy :let @+ = fnamemodify(expand("%"), ":~:.")<CR>
nmap <silent> <Leader>yr :let @+ = fnamemodify(expand("%"), ":~:.") . ":" . line(".")<CR>

xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

nmap \ gcc

" <D-Right/Left>
nmap <silent> [1;5C :tabnext<CR>
nmap <silent> [1;5D :tabprev<CR>

" <M-Left/Right/Down/Up>
nmap [1;3D <C-w>h
nmap [1;3C <C-w>l
nmap [1;3B <C-w>j
nmap [1;3A <C-w>k

" <M-c/s/v/t>
nmap c <C-w>c
nmap s <C-w>s
nmap v <C-w>v
nmap t <C-w>T

" <M-./,/k/j>
nmap . 3<C-w>>
nmap , 3<C-w><
nmap k <C-w>-
nmap j <C-w>+

" <M-a/x/z/]/\/\\>
nmap a :w<CR>
nmap x :bd<CR>
nmap z :MaximizerToggle!<CR>
nmap w :FixWhitespace<CR>
nmap / :let @/ = ''<CR>

" }}}

" Tab autocompletion + snippets {{{

imap <expr> <CR> <SID>myCR()
imap <expr> <Tab> <SID>myTab()
imap <expr> <Up> <SID>myUp()
imap <expr> <Down> <SID>myDown()

function! s:myCR()
  return pumvisible() ? "\<C-y>" : "\<CR>\<Space>\<BS>"
endfunction

function! s:triggerSnippet()
  return "\<C-r>=snipMate#TriggerSnippet()\<CR>"
endfunction

function! s:myTab()
  " Clear SnipMate tab stops
  if exists('b:snip_state')
    call b:snip_state.remove()
  endif
  return pumvisible() ? "\<C-e>" :
\     <SID>snipMateCanBeExpanded() ? <SID>triggerSnippet() :
\       <SID>checkBackSpace() ?  "\<Tab>" :
\       <SID>autoCompleteFunction()
endfunction

function! s:autoCompleteFunction()
  if &ft == 'css' || &ft == 'sass' || &ft == 'scss'
    return "\<C-x>\<C-o>"
  else
    return "\<C-n>"
  endif
endfunction

function! s:myUp()
  return pumvisible() ? "\<C-p>" : "\<Up>"
endfunction

function! s:myDown()
  return pumvisible() ? "\<C-n>" : "\<Down>"
endfunction

function! s:checkBackSpace()
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction

function! s:snipMateCanBeExpanded()
  let word     = snipMate#WordBelowCursor()
  let snippets = map(snipMate#GetSnippetsForWordBelowCursor(word, 0), 'v:val[0]')
  let matches  = filter(snippets, "v:val =~# '\\V\\^" . escape(word, '\') . "\\$'")
  return len(matches) > 0
endfunction

" }}}
